title Claim Flow



actor User

entryspacing 0.9
User->Next.JS: Try to fetch `/status`
Next.JS->Redis: Query {job:address}
Redis->Next.JS: Return {state, txHash}?
Next.JS->User: Return {state, txHash}?
note over User: Assume the object returned is undefined
User->Next.JS: Request nonce for challenge POST `/challenge` {address}
Next.JS->Redis: Check if challenge already issued (if it is, try to fetch txHash)
note over Next.JS: If the challenge was already issued, return the tx hash of the processed request
Next.JS->Next.JS: Generate random challenge
Next.JS->Redis: Store challenge (`challenge:address`)
Next.JS->User: Return challenge {challenge, txHash?}
note over User: If txHash returned, start polling the status
User->User: Sign challenge
User->Next.JS: POST challenge to `/claim` {address, sig}
Next.JS->Redis: Lookup challenge, ensure exists
Next.JS->Next.JS: Verify sig
note over Next.JS: Server has: address, challenge (assume valid)
Next.JS->Redis: Check for {job:address} (if exists, return it)
note over Next.JS: Assume {job:address} does not exist (first claim)
Next.JS->Redis: Put job on queue (address, challenge)
Queue Processor-->>Redis: Check for new job
Queue Processor->Redis: Fetch {job:address} -> {state: PROCESSING | DONE | ERROR, txHash?: string}
note over Queue Processor: Assume the job is new

Queue Processor->Redis: Store {job:address} {state: PROCESSING, txHash: undefined}
Queue Processor->Queue Processor: Do the random selection
Queue Processor->Queue Processor: Exeucute tx to claim/transfer
Queue Processor->Redis: Update {job:address} {state: PROCESSING, txHash: hash}
